#include "GpuResourceManager.h"
#include "PipelineState.h"
#include "DescriptorHeap.h"
#include "GpuResource.h"
#include "CommandContext.h"
#include "SharedMaterial.h"
#include "MeshRenderSet.h"
#include "stdafx.h"
#include <cassert>
#include <LMath.h>

GpuResourceManager* Singleton<GpuResourceManager>::_singleton = 0;

WString convertWString(const String& srcStr) {
	std::wstring_convert<std::codecvt_utf8<wchar_t>, wchar_t, MyAllocator<wchar_t>> cv;

	//string→wstring UTF-8 Only No Include Japanese
	return cv.from_bytes(srcStr.c_str());
}

GpuResourceManager::~GpuResourceManager() {
	shutdown();
}

void GpuResourceManager::createSharedMaterial(ID3D12Device* device, const SharedMaterialCreateSettings& settings) {
	//頂点シェーダーキャッシュがあればそれを使う。なければ新規生成
	RefPtr<VertexShader> vertexShader = nullptr;
	if (_vertexShaders.count(settings.vertexShaderName) > 0) {
		vertexShader = _vertexShaders.at(settings.vertexShaderName).get();
	}
	else {
		UniquePtr<VertexShader> newVertexShader = makeUnique<VertexShader>();
		newVertexShader->create(settings.vertexShaderName);
		vertexShader = newVertexShader.get();
		_vertexShaders.emplace(settings.vertexShaderName, std::move(newVertexShader));
	}

	//ピクセルシェーダーキャッシュがあればそれを使う。なければ新規生成
	RefPtr<PixelShader> pixelShader = nullptr;
	if (_pixelShaders.count(settings.pixelShaderName) > 0) {
		pixelShader = _pixelShaders.at(settings.pixelShaderName).get();
	}
	else {
		UniquePtr<PixelShader> newPixelShader = makeUnique<PixelShader>();
		newPixelShader->create(settings.pixelShaderName);
		pixelShader = newPixelShader.get();
		_pixelShaders.emplace(settings.pixelShaderName, std::move(newPixelShader));
	}

	SharedMaterial* material = new SharedMaterial();
	material->create(device, vertexShader, pixelShader);

	DescriptorHeapManager& manager = DescriptorHeapManager::instance();

	//頂点シェーダーテクスチャSRV生成
	if (settings.vsTextures.size() > 0) {
		VectorArray<RefPtr<ID3D12Resource>> textures(settings.vsTextures.size());

		for (size_t i = 0; i < settings.vsTextures.size(); ++i) {
			RefPtr<Texture2D> texturePtr;
			loadTexture(settings.vsTextures[i], texturePtr);

			textures[i] = texturePtr->get();
		}

		manager.createShaderResourceView(textures.data(), &material->srvVertex, static_cast<uint32>(settings.vsTextures.size()));
	}

	//ピクセルシェーダーテクスチャSRV生成
	if (settings.psTextures.size() > 0) {
		VectorArray<RefPtr<ID3D12Resource>> textures(settings.psTextures.size());

		for (size_t i = 0; i < settings.psTextures.size(); ++i) {
			RefPtr<Texture2D> texturePtr;
			loadTexture(settings.psTextures[i], texturePtr);

			textures[i] = texturePtr->get();
		}

		manager.createShaderResourceView(textures.data(), &material->srvPixel, static_cast<uint32>(settings.psTextures.size()));
	}

	//頂点シェーダーの定数バッファサイズを取得して定数バッファ本体を生成
	VectorArray<uint32> vertexCbSizes = vertexShader->getConstantBufferSizes();
	if (!vertexCbSizes.empty()) {
		material->vertexConstantBuffer.create(device, vertexCbSizes);
	}

	//ピクセルシェーダーの定数バッファサイズを取得して定数バッファ本体を生成
	VectorArray<uint32> pixelCbSizes = pixelShader->getConstantBufferSizes();
	if (!pixelCbSizes.empty()) {
		material->pixelConstantBuffer.create(device, pixelCbSizes);
	}

	//生成したマテリアルをキャッシュに登録
	_sharedMaterials.emplace(settings.name, material);
}

//テクスチャをまとめて生成する。まとめて送るのでCPUオーバーヘッドが少ない
void GpuResourceManager::createTextures(ID3D12Device* device, CommandContext& commandContext, const VectorArray<String>& settings) {
	VectorArray<ComPtr<ID3D12Resource>> uploadHeaps(settings.size());
	auto commandListSet = commandContext.requestCommandListSet();
	ID3D12GraphicsCommandList* commandList = commandListSet.commandList;

	for (size_t i = 0; i < settings.size(); ++i) {
		Texture2D* texture = new Texture2D();
		texture->createDeferred2(device, commandList, &uploadHeaps[i], settings[i]);

		_textures.emplace(settings[i], texture);
	}

	//アップロードバッファをGPUオンリーバッファにコピー
	commandContext.executeCommandList(commandList);
	commandContext.discardCommandListSet(commandListSet);

	//コピーが終わるまでアップロードヒープを破棄しない
	commandContext.waitForIdle();
}

struct RawVertex {
	Vector3 position;
	//Vector3 normal;
	Vector2 texcoord;

	bool operator==(const RawVertex &left) const {
		return position == left.position && texcoord == texcoord;
	}
};

#define HashCombine(hash,seed) hash + 0x9e3779b9 + (seed << 6) + (seed >> 2)

namespace std {
	template<>
	class hash<RawVertex> {
	public:

		size_t operator () (const RawVertex &p) const {
			size_t seed = 0;

			seed ^= HashCombine(hash<float>()(p.position.x), seed);
			seed ^= HashCombine(hash<float>()(p.position.y), seed);
			seed ^= HashCombine(hash<float>()(p.position.z), seed);
			seed ^= HashCombine(hash<float>()(p.texcoord.x), seed);
			seed ^= HashCombine(hash<float>()(p.texcoord.y), seed);
			return seed;
		}
	};
}

#include <unordered_map>
USE_UNORDERED_MAP

#include <fbxsdk.h>
using namespace fbxsdk;
void GpuResourceManager::createMeshSets(ID3D12Device * device, CommandContext & commandContext, const String & fileName) {
	fbxsdk::FbxManager* manager = fbxsdk::FbxManager::Create();
	FbxIOSettings* ios = FbxIOSettings::Create(manager, IOSROOT);
	manager->SetIOSettings(ios);
	FbxScene* scene = FbxScene::Create(manager, "");

	FbxImporter* importer = FbxImporter::Create(manager, "");
	importer->Initialize(fileName.c_str(), -1, manager->GetIOSettings());
	importer->Import(scene);
	importer->Destroy();

	FbxGeometryConverter geometryConverter(manager);
	geometryConverter.Triangulate(scene, true);

	FbxMesh* mesh = scene->GetMember<FbxMesh>(0);
	const uint32 materialCount = mesh->GetElementMaterialCount();
	const uint32 vertexCount = mesh->GetControlPointsCount();
	const uint32 polygonCount = mesh->GetPolygonCount();
	const uint32 polygonVertexCount = 3;
	const uint32 indexCount = polygonCount * polygonVertexCount;

	FbxStringList uvSetNames;
	bool bIsUnmapped = false;
	mesh->GetUVSetNames(uvSetNames);

	FbxLayerElementMaterial* meshMaterials = mesh->GetLayer(0)->GetMaterials();

	//マテリアルごとの頂点インデックス数を調べる
	VectorArray<uint32> materialIndexSize(materialCount);
	for (int i = 0; i < polygonCount; ++i) {
		const uint32 materialId = meshMaterials->GetIndexArray().GetAt(i);
		materialIndexSize[materialId] += polygonVertexCount;
	}

	UnorderedMap<RawVertex, uint32> optimizedVertices;//重複しない頂点情報と新しい頂点インデックス
	VectorArray<UINT32> indices(indexCount);//新しい頂点インデックスでできたインデックスバッファ
	VectorArray<uint32> materialIndexCounter(materialCount);//マテリアルごとのインデックス数を管理

	optimizedVertices.reserve(indexCount);

	for (uint32 i = 0; i < polygonCount; ++i) {
		const uint32 materialId = meshMaterials->GetIndexArray().GetAt(i);
		uint32& checkIndex = materialIndexCounter[materialId];

		for (uint32 j = 0; j < polygonVertexCount; ++j) {
			const uint32 vertexIndex = mesh->GetPolygonVertex(i, j);
			FbxVector4 v = mesh->GetControlPointAt(vertexIndex);
			FbxVector4 normal;
			FbxVector2 texcoord;

			FbxString uvSetName = uvSetNames.GetStringAt(0);//UVSetは０番インデックスのみ対応
			mesh->GetPolygonVertexUV(i, j, uvSetName, texcoord, bIsUnmapped);
			mesh->GetPolygonVertexNormal(i, j, normal);

			RawVertex r;
			r.position = { (float)v[0], (float)v[1], (float)v[2] };
			//r.normal = { (float)normal[0], (float)normal[1], (float)normal[2] };
			r.texcoord = { (float)texcoord[0], (float)texcoord[1] };

			if (optimizedVertices.count(r) == 0) {
				uint32 vertexIndex = static_cast<uint32>(optimizedVertices.size());
				indices[checkIndex] = vertexIndex;
				optimizedVertices.emplace(r, vertexIndex);
			}
			else {
				indices[checkIndex] = optimizedVertices.at(r);
			}

			checkIndex++;
		}
	}

	//UnorederedMapの配列からVectorArrayに変換
	VectorArray<RawVertex> vertices(optimizedVertices.size());
	for (const auto& vertex : optimizedVertices) {
		vertices[vertex.second] = vertex.first;
	}

	manager->Destroy();

	MeshRenderSet* meshSet = new MeshRenderSet();
	ComPtr<ID3D12Resource> uploadHeaps[2] = {};
	auto commandListSet = commandContext.requestCommandListSet();
	ID3D12GraphicsCommandList* commandList = commandListSet.commandList;

	//頂点バッファ生成
	meshSet->_vertexBuffer = makeUnique<VertexBuffer>();
	meshSet->_vertexBuffer->createDeferred<RawVertex>(device, commandList, &uploadHeaps[0], vertices);

	//インデックスバッファ
	meshSet->_indexBuffer = makeUnique<IndexBuffer>();
	meshSet->_indexBuffer->createDeferred(device, commandList, &uploadHeaps[1], indices);

	//アップロードバッファをGPUオンリーバッファにコピー
	commandContext.executeCommandList(commandList);
	commandContext.discardCommandListSet(commandListSet);

	//コピーが終わるまでアップロードヒープを破棄しない
	commandContext.waitForIdle();

	MaterialSlot slot;
	slot.indexCount = static_cast<uint32>(indices.size());
	slot.indexOffset = 0;
	loadSharedMaterial("TestM", slot.material);

	meshSet->_materialSlots.emplace_back(slot);
	_meshes.emplace(fileName, std::move(meshSet));
}

void GpuResourceManager::loadSharedMaterial(const String& materialName, RefPtr<SharedMaterial>& dstMaterial) {
	assert(_sharedMaterials.count(materialName) > 0 && "マテリアルが見つかりません");
	dstMaterial = _sharedMaterials.at(materialName).get();
}

void GpuResourceManager::loadTexture(const String & textureName, RefPtr<Texture2D>& dstTexture) {
	assert(_textures.count(textureName) > 0 && "テクスチャが見つかりません");
	dstTexture = _textures.at(textureName).get();
}

void GpuResourceManager::loadMeshSets(const String & meshName, RefPtr<MeshRenderSet>& dstMeshSet) {
	assert(_meshes.count(meshName) > 0 && "メッシュが見つかりません");
	dstMeshSet = _meshes.at(meshName).get();
}

void GpuResourceManager::shutdown() {
	for (auto&& material : _sharedMaterials) {
		material.second.reset();
	}

	for (auto&& texture : _textures) {
		texture.second.reset();
	}

	_sharedMaterials.clear();
	_textures.clear();
}
